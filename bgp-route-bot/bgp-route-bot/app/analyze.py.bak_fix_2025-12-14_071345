
from collections import Counter



# 接入层白名单（你样例里的 T2）

ACCESS_WHITELIST = {"CMI", "China Unicom", "China Telecom", "CMIN2"}



# 你样例里主要想看的上游（T3）

UPSTREAM_WHITELIST = {"Telia", "Lumen", "Cogent", "HE", "TATA Communications"}





def normalize_asn_label(asn: int, name: str | None) -> str:

    n = (name or "").strip()

    nu = n.upper()



    # 强制映射（避免名字缺失）

    if asn == 56040:

        return "CM"

    if asn == 58453:

        return "CMI"

    if asn == 1299:

        return "Telia"

    if asn == 3356:

        return "Lumen"

    if asn == 174:

        return "Cogent"

    if asn == 6939:

        return "HE"

    if asn == 6453:

        return "TATA Communications"



    if "CHINA MOBILE" in nu or "CMNET" in nu:

        return "CM"

    if "CHINA UNICOM" in nu or "UNICOM" in nu:

        return "China Unicom"

    if "CHINA TELECOM" in nu:

        return "China Telecom"

    if "CMIN2" in nu:

        return "CMIN2"



    if "TELIA" in nu:

        return "Telia"

    if "LUMEN" in nu or "LEVEL 3" in nu or "CENTURYLINK" in nu:

        return "Lumen"

    if "COGENT" in nu:

        return "Cogent"

    if "HURRICANE" in nu or "HE.NET" in nu:

        return "HE"

    if "TATA" in nu:

        return "TATA Communications"



    return n[:60] if n else f"AS{asn}"





def _clean_as_path(as_path: list[int]) -> list[int]:

    out = []

    prev = None

    for a in as_path:

        if a == 0:

            continue

        if prev == a:

            continue

        out.append(a)

        prev = a

    return out





def path_to_labels_full(as_path: list[int], asn_name: dict[int, str]) -> list[str]:

    p = _clean_as_path(as_path)

    return [normalize_asn_label(a, asn_name.get(a)) for a in p]





def _dedup_labels(labels: list[str]) -> list[str]:

    out = []

    for x in labels:

        if not out or out[-1] != x:

            out.append(x)

    return out





def _t1_key(labels: list[str]) -> tuple[str, ...] | None:

    labels = _dedup_labels(labels)

    return ("CM",) if labels and labels[-1] == "CM" else None





def _t2_key(labels: list[str]) -> tuple[str, ...] | None:

    labels = _dedup_labels(labels)

    if not labels or labels[-1] != "CM":

        return None

    if len(labels) < 2:

        return None

    a = labels[-2]

    if a in ACCESS_WHITELIST:

        return (a, "CM")

    return None  # 非白名单不显示（让 T2 更像你样例）





def _t3_key(labels: list[str]) -> tuple[str, ...] | None:

    labels = _dedup_labels(labels)

    if not labels or labels[-1] != "CM":

        return None

    if len(labels) < 3:

        return None



    up = labels[-3]

    acc = labels[-2]



    # 你样例重点是 “* -> CMI -> CM”，因此优先收敛到这类结构

    if acc in ACCESS_WHITELIST:

        # 上游白名单：只统计你关心的那几家（更像你样例）

        if up in UPSTREAM_WHITELIST:

            return (up, acc, "CM")

    return None





def summarize_like_sample(paths_full_labels: list[list[str]]) -> str:

    total = len(paths_full_labels)

    if total == 0:

        return "路由分析:\n(无数据)"



    c1 = Counter()

    c2 = Counter()

    c3 = Counter()



    for labels in paths_full_labels:

        k1 = _t1_key(labels)

        if k1:

            c1[k1] += 1

        k2 = _t2_key(labels)

        if k2:

            c2[k2] += 1

        k3 = _t3_key(labels)

        if k3:

            c3[k3] += 1



    lines = ["路由分析:"]



    # T1（固定 CM）

    for k, v in c1.most_common():

        pct = v * 100.0 / total

        lines.append(f"{pct:.1f}% [T1] {k[0]}")



    # T2（只显示白名单接入层）

    for k, v in c2.most_common(20):

        pct = v * 100.0 / total

        lines.append(f"{pct:.1f}% [T2] {k[0]} -> {k[1]} -> END")



    # T3（只显示白名单上游 + 接入层）

    for k, v in c3.most_common(20):

        pct = v * 100.0 / total

        lines.append(f"{pct:.1f}% [T3] {k[0]} -> {k[1]} -> {k[2]} -> END")



    return "\n".join(lines)

